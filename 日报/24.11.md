# 1

## EACH

今天早上是7:50起来的，还算不错，因为昨天是12:10睡的觉。早上有原生的课程，也就是AWS的LAb实验，我记错了时间，以为是9点，其实是10点,起床吃了个饭，实在是太饿了，做了方便面吃。也是和大爷一块儿上,坤坤和tylor还是起不来,我们两人就一台电脑,我不给他用(其实是要看文档)所有AWS教育的课程应该是结束了，然后大作业时间也是在12月的3号，还有一个月的时间可以好好准备一下，其他的实验也需要每周去补一补。

课程上，主要就是对之前做了一些总结，然后在LAB的细节上，老师给我们重点讲了讲computing,其他的也就没什么。然后督促我们要早点儿把LAB做完。这个其实一直是我的痛,上一次的lab实在是太多了，推进到LAB3还是有点儿问题。那个实验还得重新做，而且涉及到它最核心的computing的模块，估计得上两三天才能把它再完成了。下了课就去了Sainsbury。结果发现Sainsbury的牛排特别的便宜，四块儿才五英镑,我爱它,爱得深沉,以后Sainsbury就是我的初恋了。接着买了点儿茄子、青椒，回头做点儿地三鲜,因为冰箱里还有两块儿土豆.又去中超去转了转，任意消费就能送盲盒，还是很不错的。我开了一个,一般般,看Mandy老师那个挺漂亮的.

中午，因为实在饿的不行，所以就把那个牛肉切了点儿。下了点儿午餐肉豆芽以及最喜欢的大白菜,粉条。粉条之前有泡,在我出门的时候就已经泡上了,到回来大概有四个小时吧，炒了火锅底料，加了点郫县豆瓣酱，又撒了点花椒以及干辣椒。因为我们用第二个锅可以烧热油，所以这个比较可惜。上次是借昊玉的锅,但不好意思接着借，就没泼油,但照样不错，又切了点儿蒜末进去，非常的香，基本好吃。水煮肉片儿这块我是拿捏住了，因为用的是牛排的肉，所以只需要烫两分钟它就熟了,一次差点吃撑,出发前体重74.05吃完79.4,下次不敢这么报复性饮食了,毁我一周业力。

![24.11.1.1](../asset/image/24.11.1.1.jpg)

下午就接着去看computing的lab3部分,量还是大.再加上因为周五有点儿心猿意马，导致还是没有看完。晚上的时候去Google社区,论坛里面转了转，也没什么实际的收获，重点还是要看后面匹配的Flutter开发指南以及yu老师的课程。这两个结合起来看，我觉得效率还是比较高的。我的目标就是争取在下周,把yu老师的视频全部看完，因为现在a w s lab的实验可以往后再稍微推一下,统计斌并行再看一看，这个月应该还是要重点关注一下TIBS,考试快到了.



# 2

## Each

西巴!西巴!西巴!

先让故事回到最初的起点，早上8:40，我起了床，彼时的我还不知道接下来会面临一些什么，总之一切都很糟糕。这是我一醒来,就意识到的事情,可能是昨天睡的有点儿晚，等真正入眠都到凌晨一点多了。早上起来脑袋嗡嗡的，洗漱完之后毫无动力，什么都不想干，就搁那儿发呆,硬发呆。接着，本来是打算看yu老师的视频的，结果点开了B站就没了动力，告诉自己不如先娱乐放松一会儿。每一个视频都很无聊，但是不知道为什么，我就是一直在看，一直在看，把影视飓风从春季的视频一直看到了最新一集。

时间转瞬即逝,我没反应过来就到了11点.

麻木的看到了中午想着做饭扭转一下后昨天还剩了一些汤料，今天可以偷懒再复用一下，把剩下所有的豆芽和另外一半儿的午餐肉全部丢了进去，白菜也掰了掰，大概十个帮子，加了点儿郫县豆瓣酱，没有粉条，也没有牛肉，热了两个红薯。照片有点寒碜,就没po,看这架势,中午也就没有必要去午休了，大概两点半之后开始学习。大概学习了两个小时，手机就被源源不断的信息塞满了。

今天是BLG和T1的冠军争夺战，我想也是决定着未来联盟玩家基础的一场大战，但结果呢,阿一西巴，至于我的想法,请看VCR:

----------------------------------------------------------------------------------------------------------------------------------------------------------

**主播**：国足的这场耻辱性的大败，已经成为了这两天中国体育界最大的话题。我们来看一下前冠军硬币哥对此的点评。一向直性子的大币将军直言道，lpl这样输只怕是连面子都不要了。

**Doinb**: 你说职能部门，一届一届换了多少lpl教练了，改过吗？换汤不换药啊，人家朱开也有理由说的，我（曾经）带的是什么队，我带的EDG。你这批人是什么人啊？你叫我带？lpl现在什么水平，就这么几个人，你左手什么的都在打中路，他能打吗？打不了！没这个能力知道吗？再下去要输越南了，韩国队输完输越南，再输欧洲，接下来没人输了。

**记者**：从另一方面来说，LPL是备战S15世界杯最早的队伍……

**Doinb**：（拱手）哦哟，谢天谢地了。我已经说了，你像这样的比赛本身就没有打好基础，你能跟我保证在25年或者26年这样关键比赛他能赢啊？务实一点，我劝你们，我把自己战术打法，联盟的这个理念先搞懂。tabe（王柏勤）带的蛮好的，你把他去换了干什么你告诉我？你跟G2打个3比2，你倒告诉我怎么解释？脸都不要了！

-----------------------------------------------------------------------------------------------------------------------------------------------------------



这个耻辱性的大败。已经让人麻了，导致等到比赛结束之后，剩余的两个小时都是在磨洋工，毫无斗志，也什么都不想干，中途做的最正确的一件事情就是把联盟卸载了，把我的世界下回来,我现在是厌倦了打打杀杀，再也不想碰了,以后要还是直播我的世界吧,明天11:00点,直播间名字我都想好了:EachCraft,phton的光影是真好看,折腾了快2个小时才弄出漂亮的配置.

话虽如此,特性还是稍微看了一点Widget接口的内容的:

在 Flutter 里，这个 widget 的功能是“描述一个UI元素的配置信息”，就是说， Widget 其实并不是表示最终绘制在设备屏幕上的显示元素，所谓的配置信息就是 Widget 接收的参数，比如对于 Text 来讲，文本的内容、对齐方式、文本样式都是它的配置信息。 Widget 类的声明是这样滴：

```dart
@immutable // 不可变的
abstract class Widget extends DiagnosticableTree {
  const Widget({ this.key });

  final Key? key;

  @protected
  @factory
  Element createElement();

  @override
  String toStringShort() {
    final String type = objectRuntimeType(this, 'Widget');
    return key == null ? type : '$type-$key';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense;
  }

  @override
  @nonVirtual
  bool operator ==(Object other) => super == other;

  @override
  @nonVirtual
  int get hashCode => super.hashCode;

  static bool canUpdate(Widget oldWidget, Widget newWidget) {
    return oldWidget.runtimeType == newWidget.runtimeType
        && oldWidget.key == newWidget.key;
  }
  ...
}
```



- `@immutable` 代表 Widget 是不可变的，这会限制 Widget 中定义的属性（即配置信息）必须是不可变的（final），不允许 Widget 中定义的属性变化的原因的原话是:**Flutter 中如果属性发生变化则会重新构建Widget树，即重新创建新的 Widget 实例来替换旧的 Widget 实例，所以允许 Widget 的属性变化是没有意义的，因为一旦 Widget 自己的属性变了自己就会被替换。这也是为什么 Widget 中定义的属性必须是 final 的原因。**我的理解还是有些不明白,这个不允许变化是初始化就加载好的吗?到时候再品一品吧,脑袋有点不够用说实话.
- `widget`类继承自`DiagnosticableTree`，`DiagnosticableTree`即“诊断树”，主要作用是提供调试信息。
- `Key`: 这个`key`属性类似于 React/Vue 中的`key`，主要的作用是决定是否在下一次`build`时复用旧的 widget ，决定的条件在`canUpdate()`方法中。
- `createElement()`：正如文档所言“一个 widget 可以对应多个`Element`”；Flutter 框架在构建UI树时，会先调用此方法生成对应节点的`Element`对象。这方法是 Flutter 框架隐式调用的，作者说在开发过程中基本不会调用到。
- `debugFillProperties(...)` 复写父类的方法，主要是设置诊断树的一些特性。
- `canUpdate(...)`是一个静态方法，它主要用于在 widget 树重新`build`时复用旧的 widget ，其实具体来说，应该是：是否用新的 widget 对象去更新旧UI树上所对应的`Element`对象的配置；作者附言到:通过其源码可以看到，只要`newWidget`与`oldWidget`的`runtimeType`和`key`同时相等时就会用`new widget`去更新`Element`对象的配置，否则就会创建新的`Element`。

总之很麻,很麻,很麻,毫无效率的一天,就当是调整了(感觉最近借'调整'为名而休息的接口有点多),快快步入正轨,明天最后一天浪费了就真完辣! 另外我的世界这种无欲无求的玩完后应该不会有分心,至少种田游戏对我都这样,不会老想着,对马岛还是有点太兴奋了,以后周五休息的时候再玩.

最后这一首词字面意思还是有点契合我当下的心理:

> 不向长安路上行。却教山寺厌逢迎。味无味处求吾乐，材不材间过此生。
> 宁作我，岂其卿。人间走遍却归耕。一松一竹真朋友，山鸟山花好弟兄。



# 3

## Each

今天早上8点15起来的,很奇怪,房间太暖和,会有为太热迟迟睡不着,房间太冷,起来了老想往被窝里面缩,:confused:,一根筋两头堵,

早上坐了会儿,到大概9点半才开始学习,统计lab6的答案没下来,就决定全部学习flutter,结果这一整天学习效率简直爆表,还是应证了那句话"做自己喜欢的事情拥有无限激情",中途我就没有疲倦,非常快乐.重点学习了Flutter中的四棵树, 之前的日记提过,Widget 只是描述一个UI元素的配置信息，那么真正的布局、绘制是由谁来完成的呢？

诶,且听我细细讲来:
Flutter 框架的处理流程是这样的：

1. 根据 Widget 树生成一个 Element 树，Element 树中的节点都继承自 `Element` 类。
2. 根据 Element 树生成 Render 树（渲染树），渲染树中的节点都继承自`RenderObject` 类。
3. 根据渲染树生成 Layer 树，然后上屏显示，Layer 树中的节点都继承自 `Layer` 类。

真正的布局和渲染逻辑在 Render 树中，Element 是 Widget 和 RenderObject 的粘合剂，可以理解为一个中间代理。假设有如下 Widget 树：

```dart
Container( // 一个容器 widget
  color: Colors.blue, // 设置容器背景色
  child: Row( // 可以将子widget沿水平方向排列
    children: [
      Image.network('https://www.example.com/1.png'), // 显示图片的 widget
      const Text('A'),
    ],
  ),
);
```

注意，如果 Container 设置了背景色，Container 内部会创建一个新的 ColoredBox 来填充背景，相关逻辑如下：

```dart
if (color != null)
  current = ColoredBox(color: color!, child: current);
```

而 Image 内部会通过 RawImage 来渲染图片、Text 内部会通过 RichText 来渲染文本，所以最终的 Widget树、Element 树、渲染树结构如下图所示：

![24.11.3.1](../asset/image/24.11.3.1.png)

要注意的点是：

1. 三棵树中，Widget 和 Element 是一一对应的，但并不和 RenderObject 一一对应。比如 `StatelessWidget` 和 `StatefulWidget` 都没有对应的 RenderObject。
2. 渲染树在上屏前会生成一棵 Layer 树，这个作者说将在原理篇介绍，反正现在我只需要记住以上三棵树就行。

然后11:00-12:00,直播了一会儿,诶,好玩儿,就是为了找樱花离家远航,但遇到的两个村庄都有点不满意,一个在河流旁是挺好,但高低落差太大,在峡谷中,不适合建墙.另一个是沙漠,毫无景观,无趣.

午饭做地三鲜,啊,好怀念啊,地三鲜是去年我做的最频繁的菜,久违了.

![24.11.3.2](../asset/image/24.11.3.2.jpg)

感觉滤镜有点重,这个菜老抽上的色没这么重,还是很可以的,只是可惜不舍得放油来炸,茄子火候浅了点,这也是没办法的事,一个人吃太费油了,以后少吃.

起来后呆了一会儿,那就没必要去午睡了,然后看到直播界面,突发奇想,不如直播学习,心有所动,开始实践.开直播有一种奇妙的感觉,因为标签是自习室,其实没几个人进来打扰,偶尔有几个朋友看我开播过来发条消息,其他99.99%的时间都没有观众,但就是有一种监督学习的感觉,自己有时候也能自言自语,反倒挺沉浸的.之后可以一直开着自习直播的,这样效率超高.明天上完课改个名字,我都想好了:"Each的奇妙小屋".

下午利用时间在前1个小时把对话模块终于搞完了,最后的收尾很简单就是加一个第三方的`rflutter_alert 2.0.7`

![24.11.3.3](../asset/image/24.11.3.3.gif)

毫无难度,接着想把yu老师放一下,开始复刻另一个开源项目: 国际象棋,这个老师的视频更快,视频都是加速的,就这也要1个小时,自己复刻估计得6个小时起步,说得也快,听英语就当是磨耳朵.

目前而言还是比较顺利,不过几个嵌套之后,部分地方走的比较快,还要到时候回过头来看看,目前完成了初始化和棋子的选择,1/3的进度吧,到时候给james和羊发过去,他们玩的多.我其实对国际象棋兴趣不大,目前只是觉得这个项目从思路到套件都比较理想,可以全部过一遍.

然后学到了一个很重要的`!` : Dart 语言中的空安全运算符称为“非空断言操作符”（null assertion operator）,
就是告诉 Dart 编译器你确信某个值不会是 `null`，哪怕编译器没法法在静态分析中确定这一点。

**使用场景**

1. **非空断言**: 如果有一个可空类型（比如 `String?`），想要把他视为非空类型（`String`），可以用 `!` 进行非空断言。

```dart
String? name;
// 可能会抛出异常，因为 name 可能是 null
String nonNullName = name!; 
```

`name!` 将会被视为非空，但如果 `name` 实际上为 `null`，则会在运行时抛出 `NoSuchMethodError`。

2.**从可空值获取成员**: 想从一个可空对象中获取成员时，可以用 `!` 进行非空断言。

```dart
int? length = name?.length; // 如果 name 是 null，length 也将是 null
int nonNullLength = length!; // 这里断言 length 不为 null

```

**注意事项**(文档)

- 使用 `!` 操作符要谨慎，因为如果你错误地断言了一个值实际上是 `null`，程序会在运行时抛出异常。
- 这个操作符提供了一种在不使用条件语句检查 `null` 的情况下，快速访问可能是 `null` 的值的方法，但必须确保你在使用它时知道该值在上下文中是有效的。

明天再去看看生命周期,今天效率是真高,真的爽. 哈哈

聚散匆匆不偶然。二年遍历楚山川。但将痛饮酬风月，莫放离歌入管弦。
萦绿带，点青钱，东湖春水碧连天。明朝放我东归去，后夜相思月满船。